

这是一个纯静态网页项目，包含index.html，script.js和styles.css三个文件。分为三栏，左侧为可折叠的设置栏，右侧为主体的OCR栏。主体部分是垂直排列的一系列页面校对栏。对每个页面，展示一行，最左侧是页面的图像，中间是一个转换按钮，右侧是调用dots.ocr的大模型文档提取API得到的结果。

用户点击上传按钮后，选择pdf文件，网页端利用pdf.js，将每页的pdf页面单独提取为图像，然后每个页面都在右侧OCR栏生成一行，把页面的图像放到每一行左侧，右侧校对结果先空着，等待用户点击每页的按钮时调用API识别结果。最后用户可以点击导出按钮，将文档导出为想要的形式


## PDF OCR

### 已经完成

- 搭建了页面的主体框架，仅包含index.html，script.js和styles.css三个文件。识别部分暂时使用timeout模拟。
- 实现基于API.md中描述的基于dots.ocr的API端点的实际识别功能。需要使用流式的API。
    - 其中API的base url需要作为一个设置项。
    - 在流式获取OCR结果的时候，实时将获取的json格式识别结果放到页面右侧的识别结果展示部分，方面用户观察速度和结果。使用textarea方便后期编辑。之后再处理识别解析结果的事情。
    - 流式获取结束的时候，将结果按照json格式解析，如果格式出现问题则直接报错。
- 在设置栏里面，在上传文件的按钮附近增加两个按钮，分别是，加载进度，保存进度。进度是一个json文件，filename属性是被识别的文件名。然后里面pages是每个页面数据。页面数据是OCR端点返回的格式。保存进度会将当前页面所有的识别结果保存为json下载。加载进度会从json格式里面读取识别结果并加载到页面上。加载进度的时候直接assert用户选择了文件，没有选择则提示用户先上传pdf文件。
- 把现在的“导出结果”按钮改成 “导出markdown” 的按钮。将所有识别结果的json信息里面拿出文字部分，用两个连续的换行顺序拼接文字得到markdown。
    - 忽略'Page-footer', 'Page-header'类型的块，不要将它们的text放到结果中。
    - 对于'Picture'类型的块，要为每个图片生成一个文件名，格式为filename_page_n_x1_x2_y1_y2.png，表示某文件第几页的对应坐标的图片，然后从当前页面中切割下载这个png给用户。然后在markdown中插入图片的引用，使用./开头的相对路径。如果下一个块是'Caption'类型的块，将其中的文字放到图片描述的部分。
    - 对于'Footnote'格式的块，维护一个全局的footnote序号，然后在footnote前面增加footnote专属的标记，格式如下：
    ```
    [^1]: Here is the footnote.
    ```
- 实现一个"识别所有页面"按钮。依次识别每个识别结果为空的页面，完全流式识别完一个页面后再才识别下一个。
    - 增加一个checkbox设置 “是否自动滚动到当前识别页面”，勾选后，自动识别的循环里，先滚动到对应的页面位置，再启动识别。
    - 开始识别后，“识别所有页面”按钮变成能中断识别的按钮，用户点击后，识别完一个页面后就停止
- 加载进度但是没有上传文件的时候，优先检查格式是否合法。然后检查是否上传了文件，没有上传文件时，在消息里也提示应该上传的文件名。
- 将PDF OCR页面和javascript展示给用户的相关的文字，没有设置`data-i18n`的内容设置一下，将相关翻译写入到languages/zh-CN.json和languages/en-US.json文件中。
- 支持Picture类型的框
- 更高级的OCR结果展示：在OCR识别请求结束的时候，解析为json格式之后，需要用更好的方式展示。
    - 根据bbox，
    - 在右侧的每个识别结果的识别结果栏内部，增加相关按钮，做成类似tab切换的形式，改成支持两种视图。
        - 其中json视图就是现在的json识别结果。
        - 新增加的是分块markdown视图，将每个识别结果的块的markdown原文分块用textarea可编辑地展示出来，不需要渲染markdown的格式。
            - 用户鼠标移动到每个块hover的时候，要根据bbox在左侧的pdf页面上对应位置画出高亮。
            - 视图内的编辑要直接反映到json格式中。
- 在没有出现问题的时候，不要用类似alert这种框，而是顶部弹出消息的形式。包括加载进度结束后的提示等都进行修改。
- textarea的高度调高一点，自动expand现有的空间。
- 那边pdf识别结果也实时保存？
-  让PDF OCR的js逻辑，把header和footer作为html注释的形式，也放到导出的markdown里
- &amp;?&gt;

### Roadmap

- 增加基于VLM的单个区域重新OCR的功能。支持设置Prompt。
- 支持识别layout的模型，然后再每个区域单独使用VLM识别。
- 在设置API的下面放一个部署教程链接，跳转到我那边仓库。
- 每个块支持拖动排序，增加删除按钮，和增加按钮。以及手动画框创建？

## LLM Translation

### 已经完成的：

- 顶部增加一个导航栏，类似于tab的形式，然后其中一个tab叫Translation，包含现在的所有网页内容，作为第二个tab。第一个tab叫PDF OCR，内容暂时空着，等我后面把我的pdf ocr网页融入进来。之后可以增加其他的tab方便融合其他的网页工具。
- 语言选择的设置现在在翻译子页面的设置栏里。把语言选择的设置弄得紧凑一点，然后放到右上角。这样无论在哪个子页面都能看到并切换语言
- 直接翻译状态都暂存到local storage。

### Road Map

- 右上角加一个github标志，指向源码。

### Python client

你需要写一个python脚本，模拟pdfocr.js部分的功能，写到python-client文件夹里。注意查看并复用现有的python-client/utils文件夹里面的函数。它参数接收一个pdf文件路径，然后告一个临时文件夹负责转图片，转图片的时候要注意宽度高度是28的倍数。依次识别每个页面，然后在pdf文件夹旁边维护一个同文件名，但是后缀名是.ocr_progress.json的文件，和网页版的格式保持一致，使得用户随时可以把它弄到网页版里去手动修订识别结果。最后接收一个输出文件夹路径，往里面输出识别后的markdown结果，和相关的markdown图片，和网页版的功能一致。
